static const char *purpose = "show memory map";
static const char *description =
    "Given a BAT state for a binary specimen, show the memory map on standard output.\n\n"

    "This tool reads the binary analysis state file provided as a command-line positional argument, or standard input if "
    "the name is \"-\" (a single hyphen) or not specified. The standard input mode works only on those operating systems "
    "whose standard input is opened in binary mode, such as Unix-like systems.";

#include <rose.h>
#include <BinaryVxcoreParser.h>                         // rose
#include <CommandLine.h>                                // rose
#include <Partitioner2/Engine.h>                        // rose
#include <Sawyer/Stopwatch.h>                           // rose
#include <SRecord.h>                                    // rose

#include <batSupport.h>

using namespace Rose;
using namespace Rose::BinaryAnalysis;
using namespace Sawyer::Message::Common;
namespace P2 = Rose::BinaryAnalysis::Partitioner2;

namespace {

Sawyer::Message::Facility mlog;

enum OutputFormat { OUT_NONE, OUT_HEXDUMP, OUT_SRECORDS, OUT_BINARY, OUT_VXCORE };

struct Settings {
    SerialIo::Format stateFormat;
    OutputFormat outputFormat;
    SRecord::Syntax srecordSyntax;
    std::string outputPrefix;
    std::vector<AddressInterval> where;

    Settings()
        : stateFormat(SerialIo::BINARY), outputFormat(OUT_NONE), srecordSyntax(SRecord::SREC_MOTOROLA) {}
};

// Parses the command-line and returns the name of the input file if any (the ROSE binary state).
boost::filesystem::path
parseCommandLine(int argc, char *argv[], P2::Engine &engine, Settings &settings) {
    using namespace Sawyer::CommandLine;

    //---------- Generic Switches ----------
    SwitchGroup generic = Rose::CommandLine::genericSwitches();
    generic.insert(Bat::stateFileFormatSwitch(settings.stateFormat));

    //---------- Output Switches ----------
    SwitchGroup output("Output Switches");
    output.name("out");

    output.insert(Switch("format")
                  .argument("fmt", enumParser<OutputFormat>(settings.outputFormat)
                            ->with("none", OUT_NONE)
                            ->with("hexdump", OUT_HEXDUMP)
                            ->with("srecord", OUT_SRECORDS)
                            ->with("srecords", OUT_SRECORDS)
                            ->with("binary", OUT_BINARY)
                            ->with("vxcore", OUT_VXCORE))
                  .doc("Style of output to use when dumping memory.  The choices are:"

                       "@named{none}{Don't dump any data; just show basic information about the memory map. This "
                       "is the default.}"

                       "@named{hexdump}{Show the data in a format similar to the @man{hexdump}{1} command.}"

                       "@named{srecords}{Emit the data as Motorola S-Records.}"

                       "@named{binary}{Save the data to one or more binary files, one per region of memory. The file "
                       "names are generated by appending the hexadecimal starting address (without leading \"0x\") and "
                       "the file extension \".data\" to the name supplied by the @s{prefix} switch. Additionally, an "
                       "index file is emitted to standard output and contains the command-line arguments that describe "
                       "how to load the binary files back into memory.}"

                       "@named{vxcore}{Save the data to a binary file whose format is defined by ROSE. The @s{prefix} "
                       "is used as the output file name.}"));

    output.insert(Switch("srecord-syntax")
                  .argument("syntax", enumParser<SRecord::Syntax>(settings.srecordSyntax)
                            ->with("motorola", SRecord::SREC_MOTOROLA)
                            ->with("intel", SRecord::SREC_INTEL))
                  .doc("When generating S-Record output (@s{format}=srecords), this switch controls which syntax family "
                       "to use. The choices are:"
                       "@named{motorola}{Motorola S-Record syntax." +
                       std::string(SRecord::SREC_MOTOROLA == settings.srecordSyntax ? " This is the default." : "") + "}"
                       "@named{intel}{Intel HEX syntax." +
                       std::string(SRecord::SREC_INTEL == settings.srecordSyntax ? " This is the default." : "") + "}"));

    output.insert(Switch("prefix", 'o')
                  .argument("name", anyParser(settings.outputPrefix))
                  .doc("When generating binary files (@s{format}=binary), the string argument for this switch is "
                       "prepended to the names of the binary output files as described by @s{format}. The default "
                       "is to use the base name of the input RBA file after also removing the \".rba\" extension."));

    output.insert(Switch("where")
                  .argument("interval", P2::addressIntervalParser(settings.where))
                  .whichValue(SAVE_ALL)
                  .doc("Specifies the addresses that should be dumped. The default is to dump all mapped addresses. " +
                       P2::AddressIntervalParser::docString() + "  The specified interval may include addresses "
                       "that aren't mapped and which are silently ignored. This switch may appear more than once."));

    //---------- Parsing -----------
    Parser parser = Rose::CommandLine::createEmptyParser(purpose, description);
    parser.errorStream(mlog[FATAL]);
    parser.with(generic).with(output);
    parser.doc("Synopsis", "@prop{programName} [@v{switches}] [@v{rba-state}]");

    std::vector<std::string> input = parser.parse(argc, argv).apply().unreachedArgs();
    if (input.size() > 1) {
        mlog[FATAL] <<"incorrect usage; see --help\n";
        exit(1);
    }
    if (settings.where.empty())
        settings.where.push_back(AddressInterval::whole());
    return input.empty() ? boost::filesystem::path("-") : input[0];
}

class Dumper {
public:
    void operator()(const Settings &settings, const MemoryMap::Ptr &map, const AddressInterval &dataInterval,
                    std::ostream &stream) {
        MemoryMap::ConstNodeIterator inode = map->at(dataInterval.least()).nodes().begin();
        ASSERT_forbid(inode == map->nodes().end());
        const AddressInterval &segmentInterval = inode->key();
        ASSERT_require(segmentInterval.isContaining(dataInterval));
        const MemoryMap::Segment &segment = inode->value();
        if (const uint8_t *data = segment.buffer()->data()) {
            rose_addr_t bufferOffset = segment.offset() + dataInterval.least() - segmentInterval.least();
            ASSERT_require(segment.buffer()->available(bufferOffset) >= dataInterval.size());
            formatData(stream, segmentInterval, segment, dataInterval, data+bufferOffset);
        }
    }

    virtual void formatData(std::ostream&, const AddressInterval &segmentInterval, const MemoryMap::Segment&,
                            const AddressInterval &dataInterval, const uint8_t *data) = 0;
};

class HexDumper: public Dumper {
    HexdumpFormat fmt_;
public:
    HexDumper() {
        fmt_.numeric_fmt_special[0] = "..";
        fmt_.numeric_fmt_special[0xff]= "##";
    }

    virtual void formatData(std::ostream &stream, const AddressInterval &segmentInterval, const MemoryMap::Segment &segment,
                            const AddressInterval &dataInterval, const uint8_t *data) ROSE_OVERRIDE {
        rose_addr_t va = dataInterval.least();
        rose_addr_t nRemain = dataInterval.size();

        if (dataInterval.least() == segmentInterval.least())
            stream <<"Dumping segment " <<segmentInterval <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"\n";
        if (dataInterval != segmentInterval)
            stream <<"Data for addresses " <<dataInterval <<":\n";

        // Hexdumps are typically aligned so the first byte on each line is aligned on a 16-byte address, so print
        // out some stuff to get the rest aligned if necessary.
        rose_addr_t nLeader = std::min(16 - va % 16, nRemain);
        if (nLeader != 16) {
            SgAsmExecutableFileFormat::hexdump(stream, va, data, nLeader, fmt_);
            va += nLeader;
            data += nLeader;
            nRemain -= nLeader;
            stream <<"\n";
        }

        SgAsmExecutableFileFormat::hexdump(stream, va, data, nRemain, fmt_);
        stream <<"\n";
    }
};

class SRecordDumper: public Dumper {
    SRecord::Syntax syntax_;

public:
    explicit SRecordDumper(SRecord::Syntax syntax)
        : syntax_(syntax) {}

    virtual void formatData(std::ostream &stream, const AddressInterval &segmentInterval, const MemoryMap::Segment &segment,
                            const AddressInterval &dataInterval, const uint8_t *data) ROSE_OVERRIDE {
        MemoryMap::Ptr map = MemoryMap::instance();
        map->insert(dataInterval, MemoryMap::Segment::staticInstance(data, dataInterval.size(), MemoryMap::READABLE));
        std::vector<SRecord> srecs = SRecord::create(map, syntax_);
        BOOST_FOREACH (const SRecord &srec, srecs)
            stream <<srec <<"\n";
    }
};

class BinaryDumper: public Dumper {
public:
    virtual void formatData(std::ostream &stream, const AddressInterval &segmentInterval, const MemoryMap::Segment &segment,
                            const AddressInterval &dataInterval, const uint8_t *data) ROSE_OVERRIDE {
        stream.write((const char*)data, dataInterval.size());
        if (!stream.good()) {
            std::ostringstream mesg;
            mesg <<"write failed for virtual addresses " <<dataInterval <<" in segment " <<segmentInterval
                 <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"";
            throw std::runtime_error(mesg.str());
        }
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace

int
main(int argc, char *argv[]) {
    ROSE_INITIALIZE;
    Diagnostics::initAndRegister(&mlog, "tool");
    mlog.comment("listing info about virtual memory maps");
    Bat::checkRoseVersionNumber(MINIMUM_ROSE_LIBRARY_VERSION, mlog[FATAL]);
    Bat::registerSelfTests();

    P2::Engine engine;
    Settings settings;
    boost::filesystem::path inputFileName = parseCommandLine(argc, argv, engine, settings);
    P2::Partitioner partitioner = engine.loadPartitioner(inputFileName, settings.stateFormat);
    MemoryMap::Ptr map = partitioner.memoryMap();
    ASSERT_not_null(map);

    if (OUT_NONE == settings.outputFormat) {
        switch (partitioner.memoryMap()->byteOrder()) {
            case ByteOrder::ORDER_LSB:
                std::cout <<"default byte order is little-endian\n";
                break;
            case ByteOrder::ORDER_MSB:
                std::cout <<"default byte order is big-endian\n";
                break;
            case ByteOrder::ORDER_UNSPECIFIED:
                std::cout <<"default byte order is unspecified\n";
                break;
        }
        partitioner.memoryMap()->dump(std::cout);

    } else if (OUT_VXCORE == settings.outputFormat) {
        if (settings.outputPrefix.empty()) {
            mlog[FATAL] <<"an output file must be specified for binary output formats\n";
            exit(1);
        }
        std::string outputName = settings.outputPrefix;
        std::ofstream output(outputName.c_str(), std::ios_base::binary);
        if (!output.good())
            throw std::runtime_error("cannot create \"" + outputName);
        Rose::BinaryAnalysis::VxcoreParser parser;
        BOOST_FOREACH (AddressInterval where, settings.where)
            parser.unparse(output, map, where, "output");
        exit(0);

    } else {
        BOOST_FOREACH (AddressInterval where, settings.where) {
            rose_addr_t va = where.least();
            while (AddressInterval interval = map->atOrAfter(va).singleSegment().available()) {
                interval = interval.intersection(where);
                ASSERT_forbid(interval.isEmpty());
                MemoryMap::ConstNodeIterator inode = map->at(interval.least()).nodes().begin();
                const AddressInterval &segmentInterval = inode->key();
                const MemoryMap::Segment &segment = inode->value();

                switch (settings.outputFormat) {
                    case OUT_NONE:
                        ASSERT_not_reachable("handled already above");
                    case OUT_HEXDUMP:
                        HexDumper()(settings, map, interval, std::cout);
                        break;
                    case OUT_SRECORDS:
                        SRecordDumper(settings.srecordSyntax)(settings, map, interval, std::cout);
                        break;
                    case OUT_BINARY: {
                        boost::filesystem::path outputName = settings.outputPrefix +
                                                             StringUtility::addrToString(interval.least()).substr(2) +
                                                             ".data";
                        std::ofstream output(outputName.native().c_str());
                        if (!output.good()) {
                            mlog[FATAL] <<"cannot create output file " <<outputName <<"\n";
                            exit(1);
                        }
                        BinaryDumper()(settings, map, interval, output);
                        std::cout <<"# Segment " <<segmentInterval <<" \"" <<StringUtility::cEscape(segment.name()) <<"\"\n"
                                  <<"map:" <<StringUtility::addrToString(segmentInterval.least())
                                  <<"+" <<StringUtility::addrToString(segmentInterval.size())
                                  <<"=" <<(0!=(segment.accessibility() & MemoryMap::READABLE) ? "r" : "")
                                  <<(0!=(segment.accessibility() & MemoryMap::WRITABLE) ? "w" : "")
                                  <<(0!=(segment.accessibility() & MemoryMap::EXECUTABLE) ? "x" : "")
                                  <<"::" <<outputName <<"\n\n";
                        break;
                    }
                    case OUT_VXCORE:
                        ASSERT_not_reachable("handled above");
                }
                if (interval.greatest() == where.greatest())
                    break;                                  // to prevent possible overflow
                va = interval.greatest() + 1;
            }
        }
    }
}
